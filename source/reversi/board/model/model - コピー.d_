module reversi.board.impl.model;

import reversi.board.intf.board;
import reversi.board.impl.modelbase;

// import srd.stdio;
import std.conv : to;
import std.typecons;


class ReversiModel(int N = 8) : ReversiModelBase!N
{
private:
    static const Memo!N memo;// = new Memo!N;
    Tuple!(int, int, Stone)[][] diff;

    struct Lines
    {
        Stone[] ver;
        Stone[] hor;
        Stone[] diag;
        Stone[] diag_r;
    }

    Lines getLines(in int x, in int y) const
    {
        Lines ret;
        foreach(i; 0..N)
        {
            ret.ver ~= this[x, i];
            ret.hor ~= this[i, y];
        }

        if(x < y)
            foreach(i; 0..N+x-y)
                ret.diag ~= this[i, i + y - x];
        else
            foreach(i; 0..N+y-x)
                ret.diag ~= this[i + x - y, i];

        if(x + y < N - 1)
            foreach(i; 0..x+y +1)
                ret.diag_r ~= this[i, -i + x + y];
        else
            foreach_reverse(i; x+y-N+1..N)
                ret.diag_r ~= this[-i + x + y, i];

        return ret;
    }

public:
    static this()
    {
        memo = new Memo!N;

    }

    override bool canPutStone(in int x, in int y) const
    {
        if(!this[x, y].isNone)
            return false;

        const lines = getLines(x, y);

        if(memo[lines.ver, turn, y])
            return true;
        if(memo[lines.hor, turn, x])
            return true;
        if(memo[lines.diag, turn, (x < y) ? x: y])
            return true;
        if(memo[lines.diag_r, turn, (x+y < N-1) ? x: N-1-y])
            return true;
        return false;
    }

    override int countObtainStoneWhenPut(in int x, in int y) const
    {
        assert(0, "Not supported");
    }

    override void putStone(in int x, in int y)
    {
        putStone!false(x, y);
    }

    void putStone(bool save)(in int x, in int y)
    {
        const lines = getLines(x, y);
        bool is_put = false;

        static if(save)
            diff ~= null;

        if(const p = memo[lines.ver, turn, y])
        {
            // write("1");
            is_put = true;
            foreach(i; 0..N)
            {
                static if(save)
                    diff[$-1] ~= tuple(x, i, this[x, i]);
                this[x, i] = (*p)[i];
            }
        }
        // writeln(lines.hor);

        if(const p = memo[lines.hor, turn, x])
        {
            // write("1");
            is_put = true;
            foreach(i; 0..N)
            {
                static if(save)
                    diff[$-1] ~= tuple(i, y, this[i, y]);
                this[i, y] = (*p)[i];
            }
        }
        // writeln(lines.ver);

        if(const p = memo[lines.diag, turn, (x < y) ? x: y])
        {
            // write("1");
            is_put = true;
            if(x < y)
                foreach(i; 0..N+x-y)
                {
                    static if(save)
                        diff[$-1] ~= tuple(i, i + y - x, this[i, i + y - x]);
                    this[i, i + y - x] = (*p)[i];
                }
            else
                foreach(i; 0..N+y-x)
                {
                    // writeln(">",i);
                    static if(save)
                        diff[$-1] ~= tuple(i + x - y, i, this[i + x - y, i]);
                    this[i + x - y, i] = (*p)[i];
                }
        }
        // writeln(lines.diag);

        if(const p = memo[lines.diag_r, turn, (x+y < N-1) ? x: N-1-y])
        {
            // write("1");
            is_put = true;
            if(x + y < N - 1)
                foreach(i; 0..x+y +1)
                {
                    static if(save)
                        diff[$-1] ~= tuple(i, -i + x + y, this[i, -i + x + y]);
                    this[i, -i + x + y] = (*p)[i];
                }
            else
                foreach_reverse(i; x+y-N+1..N)
                {
                    static if(save)
                        diff[$-1] ~= tuple(-i + x + y, i, this[-i + x + y, i]);
                    this[-i + x + y, i] = (*p)[i];
                }
        }
        // writeln(lines.diag_r);

        pass();

        if(!is_put)
            throw new Exception("cannot put at ("~x.to!string~","~y.to!string~")");
    }

    void popDiff()
    {
        if(diff.length == 0)
            throw new Exception("pop error");

        foreach(d; diff[$-1])
            this[d[0], d[1]] = d[2];

        diff = diff[0..$-1];
    }

}


private class Memo(int N)
{
public:
    const(Stone[]*) opIndex(in Stone[] line, in Stone s, in int x) const
    {
        if(const p1 = line in memo_)
            if(const p2 = s in *p1)
                if(const p3 = x in *p2)
                    return p3;
        return null;
    }
int cnt = 0;
int cnt1 = 0;
private:
    Stone[]
        [int][Stone][immutable Stone[]]
            memo_;


    void opIndexAssign(in Stone[] line1, in Stone[] line, in Stone s, in int x)
    {
        memo_[line.idup][s][x] = line1.dup;
    }

    this()
    {
        foreach(immutable n; 3..N+1)
            calcMemo1(n);
    }

    void calcMemo1(in int n)
    {
        auto line = new Stone[n];
        line[] = Stone.none;
        calcMemo2(n, 0, line);
    }

    void calcMemo2(in int n, in int i, Stone[] line)
    {
        if(i == n)
        {
            //if(cnt1 < 100)
              //  writeln(line);
            calcMemoPut(n, line);
        }
        else
        {
            foreach(s; eachStone)
            {
                line[i] = s;
                calcMemo2(n, i + 1, line);
            }
        }
    }
int a = 3;
    void calcMemoPut(in int n, in Stone[] line)
    {
        bool put(in Stone stone, in int x, ref Stone[] l)
        {
            bool changed = false;
            foreach(j; x+1..n)
            {
                immutable s = l[j];
                if(s.isNone)
                {
                    break;
                }
                else if(s == stone)
                {
                    if(j == x + 1)
                        break;
                    l[x+1..j+1] = stone;
                    changed = true;
                }
            }
            foreach_reverse(j; 0..x)
            {
                immutable s = l[j];
                if(s.isNone)
                {
                    break;
                }
                else if(s == stone)
                {
                    if(j == x - 1)
                        break;
                    l[j..x] = stone;
                    changed = true;
                }
            }
            if(changed)
                l[x] = stone;
            return changed;
        }

        foreach(x; 0..n)
        {
            if(line[x] == Stone.none)
            {
                Stone[] l = line.dup;
                if(put(Stone.black, x, l))
                {
                    ++cnt;
                    this[line, Stone.black, x] = l;
                }

                l = line.dup;
                if(put(Stone.white, x, l))
                {
                    ++cnt;
                    this[line, Stone.white, x] = l;
                }
            }
            ++cnt1;

           // if(cnt1 % 500 == 0)
                //writefln("all(%6s), t(%6s)",cnt1,cnt);
        }
    }
}

